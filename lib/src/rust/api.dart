// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SENSOR_SINK`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `initialize`

Stream<SensorData> createSensorStream() =>
    RustLib.instance.api.crateApiCreateSensorStream();

Future<String> startServer({required int port, required bool isUdp}) =>
    RustLib.instance.api.crateApiStartServer(port: port, isUdp: isUdp);

Future<bool> stopServer() => RustLib.instance.api.crateApiStopServer();

Future<void> reportToFlutter(
        {required List<int> air,
        required List<int> slider,
        required int coin,
        required int service,
        required int test,
        required String code}) =>
    RustLib.instance.api.crateApiReportToFlutter(
        air: air,
        slider: slider,
        coin: coin,
        service: service,
        test: test,
        code: code);

Future<void> syncToShmem(
        {required List<int> air,
        required List<int> slider,
        required int coin,
        required int service,
        required int test,
        required String code}) =>
    RustLib.instance.api.crateApiSyncToShmem(
        air: air,
        slider: slider,
        coin: coin,
        service: service,
        test: test,
        code: code);

class SensorData {
  final Uint8List air;
  final Uint8List slider;
  final int coin;
  final int service;
  final int test;
  final String code;

  const SensorData({
    required this.air,
    required this.slider,
    required this.coin,
    required this.service,
    required this.test,
    required this.code,
  });

  @override
  int get hashCode =>
      air.hashCode ^
      slider.hashCode ^
      coin.hashCode ^
      service.hashCode ^
      test.hashCode ^
      code.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SensorData &&
          runtimeType == other.runtimeType &&
          air == other.air &&
          slider == other.slider &&
          coin == other.coin &&
          service == other.service &&
          test == other.test &&
          code == other.code;
}
